三、16-bit常数 
　　为了增加处理常数的灵活性，新架构中为Thumb-2指令集和ARM指令集增加了两条新的指令。
MOVW可以把一个16-bit常数加载到寄存器中，并用0填充高比特位；另一条指令MOVT可以把一个16-bit常数加载到寄存器高16比特中。
这两条指令组合使用就可以把一个32-bit常数加载到寄存器中。
通常在访问外设寄存器之前会把外设的基址加载到寄存器中，这时就会需要把32-bit常数加载到寄存器中。
在之前的架构中需要通过literal pools来完成这样的操作，对32位常量的访问一般通过PC相对寻址来实现。
Literal pools可以保存常量并简化访问这些常量的代码，但是，在Harvard架构的处理器中会引起额外的开销。
这些开销来自于需要额外的时钟周期来使数据端口能够对指令流进行访问；这种访问可能是需要把指令流加载的数据缓存中，
或者从数据端口直接访问指令存储器。将32位常量分成16比特的两个部分保存在两条指令中，意味着数据直接在指令流中，
不再需要通过数据端口来访问了。相对于literal pool方式，这种解决办法可以消除通过数据端口访问指令流的额外开销，进而提高性能，降低功耗。


MOVW r1,#:lower16:_functionPointer
MOVT r1,#:upper16:_functionPointer 

MOVW            R3, #0x2706

"\x42\xf2\x06\x73"		低字节-->高字节  73 06 f2 42 	强制转换为整型 1123157619


