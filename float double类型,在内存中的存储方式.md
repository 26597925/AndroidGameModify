# 存储方式
 任何数据在内存中都是以二进制（0或1）顺序存储的，每一个1或0被称为1位    
C/C++编译器标准都遵照IEEE制定的浮点数表示法来进行float,double运算    
这种结构是一种科学计数法，用符号、指数和 尾数来表示，底数定为2――即把一个浮点数表示为尾数乘以2的指数次方再添上符号    

```
		  符号位 阶码  尾数  长度

    float   1     8     23    32

    double  1     11    52    64
```

# float
https://blog.csdn.net/darkfaker/article/details/78723762    

```
例如19.25 换算成float类型：
1.先化为二进制：0001 0011.01
2.再将二进制写为：1.001101*2的4次方（小数点左移一位相当于原数除以2）
因为小数点前必为1，所以IEEE规定只记录小数点后的数，即底数为001101。
3.上数为 底数*2的4次方，所以指数部分e=4,加上127后为131，二进制数为10000011
4.符号位s,由于为正数，s=0;
所以19.25的float的格式为
0 100 0001 1001 1010 0000 0000 0000 0000
它的16进制数为
0x 4 1 9 A 0 0 0 0
VS中用内存显示的19.25在内存中的储存数。可以看到使用的是小端模式存储。
```

# double
https://www.cnblogs.com/xinjun/archive/2010/03/08/1680908.html     

```
	由于通常C编译器默认浮点数是double型的，下面以double为例： 共计64位，折合8字节。

    由最高到最低位分别是第63、62、61、……、0位： 最高位63位是符号位，1表示该数为负，0正； 62-52位，一共11位是指数位； 51-0位，一共52位是尾数位。

     按照IEEE浮点数表示法，下面将把double型浮点数38414.4转换为十六进制代码。

     把整数部和小数部分开处理:整数部直接化十六进制：960E。小数的处理: 0.4=0.5*0+0.25*1+0.125*1+0.0625*0+…… 实际上这永远算不完！这就是著名的浮点数精度问题。所以直到加上前面的整数部分算够53位就行了（隐藏位技术：最高位的1 不写入内存）。

     如果你够耐心，手工算到53位那么因该是：38414.4(10)=1001011000001110.0110101010101010101010101010101010101(2)

     科学记数法为：1.001……乘以2的15次方。指数为15！ 于是来看阶码，一共11位，可以表示范围是-1024 ~ 1023。因为指数可以为负，为了便于计算，规定都先加上1023，在这里， 15+1023=1038。

     二进制表示为：100 00001110 符号位：正―― 0 ！ 合在一起（尾数二进制最高位的1不要）： 01000000 11100010 11000001 11001101 01010101 01010101 01010101 01010101 按字节倒序存储的十六进制数就是： 55 55 55 55 CD C1 E2 40。
```